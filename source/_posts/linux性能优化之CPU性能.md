---
layout: post
title: linux 性能优化之CPU性能
date: 2020-05-30
tags: linux
categories: 操作系统
---
读《Linux性能优化实战》的总结

<!--more-->

# 平均负载

## 平均负载的概念

1. 观察系统CPU负载的常用命令`uptime`和`top`。
2. uptime 输出值各字段含义：当前时间、系统运行时间、正在登录用户数、过去 1 分钟、5 分钟、15 分钟的平均负载（Load Average）。
3. 平均负载是指单位时间内，系统处于可运行状态(R)和不可中断状态(D)的平均进程数，也就是平均活跃进程数，它和 CPU 使用率并没有直接关系。
4. 它不仅包括了正在使用 CPU 的进程，还包括等待 CPU 和等待 I/O 的进程。

6. 查询cpu个数 `grep 'model name' /proc/cpuinfo | wc -l`，或者 `lscpu`。

7. 当平均负载高于 CPU 数量 70% 的时候，你就应该分析排查负载高的问题了。

## 分析负载的案例

1. 安装 stress 和 sysstat `apt install stress sysstat`

### CPU 密集型

1. stress 施加压力 `stress --cpu 1 --timeout 600`

2. 观察平均负载变化 `watch -d uptime`

3. 观察所有CPU的使用情况 `mpstat -P ALL 5`

4. 按线程观察CPU使用情况 `pidstat -u 5 1`

### io 密集型

1. 施加io压力 `stress -i 1 --timeout 600`

2. 观察CPU情况，系统 CPU 使用率升高到了 23.87，而 iowait 高达 67.53%。这说明，平均负载的升高是由于 iowait 的升高。

### 大量进程场景

1. 施加多进程压力，`stress -c 8 --timeout 600`

2. `pidstat -u 5 1` 会发现每个进程等待CPU的时间为 75%。

# 上下文切换

## CPU 上下文切换

1. 每个任务运行前，需要系统事先帮它设置好 CPU 寄存器和程序计数器。

2. CPU 上下文切换，就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。

3. 根据任务的不同，CPU 的上下文切换就可以分为几个不同的场景，也就是进程上下文切换、线程上下文切换以及中断上下文切换。

### 进程上下文切换

1. 一次系统调用的过程，其实是发生了两次 CPU 上下文切换。

2. 进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。

3. 进程的上下文切换就比系统调用时多了一步：在保存当前进程的内核状态和 CPU 寄存器之前，需要先把该进程的虚拟内存、栈等保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

4. 每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。

5. 发生进程切换的场景。
  a. 某个进程的时间片耗尽了，就会被系统挂起。
  b. 进程在系统资源不足（比如内存不足）时
  c. 当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时
  d. 当有优先级更高的进程运行时
  e. 发生硬件中断时

### 线程上下文切换

1. 对于线程和进程，我们可以这么理解：
  a. 当进程只有一个线程时，可以认为进程就等于线程。
  b. 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。
  c. 线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。

### 中断上下文切换

1. 中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。

## 上下文切换的案例分析

1. vmstat 是一个常用的系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析 CPU 上下文切换和中断的次数。

2. cs（context switch）是每秒上下文切换的次数。in（interrupt）则是每秒中断的次数。r（Running or Runnable）是就绪队列的长度，也就是正在运行和等待 CPU 的进程数。b（Blocked）则是处于不可中断睡眠状态的进程数。

3. `pidstat -w 5` 输出每个进程的切换情况。

4. cswch ，表示每秒自愿上下文切换（voluntary context switches）的次数，另一个则是 nvcswch ，表示每秒非自愿上下文切换（non voluntary context switches）的次数。

### 多线程切换案例

1. `sysbench --num-threads=10 --max-time=3000 --test=threads run` 跑线程测试。sysbench 是一个多线程的基准测试工具，一般用来评估不同系统参数下的数据库负载情况。

2. `pidstat -wt 1` 输出线程的上下文切换指标。

### 总结
碰到上下文切换次数过多的问题时，我们可以借助 vmstat 、 pidstat 和 /proc/interrupts 等工具，来辅助排查性能问题的根源。

## CPU使用率分析

### 定义

1. 节拍率（内核中表示为 HZ），触发时间中断，并使用全局变量 Jiffies 记录了开机以来的节拍数。

2. `grep 'CONFIG_HZ=' /boot/config-$(uname -r)` 获取节拍率。

3. `cat /proc/stat | grep ^cpu` 获取CPU使用时间分配。
具体每个列的含义
```
user（通常缩写为 us），代表用户态 CPU 时间。注意，它不包括下面的 nice 时间，但包括了 guest 时间。
nice（通常缩写为 ni），代表低优先级用户态 CPU 时间，也就是进程的 nice 值被调整为 1-19 之间时的 CPU 时间。这里注意，nice 可取值范围是 -20 到 19，数值越大，优先级反而越低。
system（通常缩写为 sys），代表内核态 CPU 时间。
idle（通常缩写为 id），代表空闲时间。注意，它不包括等待 I/O 的时间（iowait）。
iowait（通常缩写为 wa），代表等待 I/O 的 CPU 时间。
irq（通常缩写为 hi），代表处理硬中断的 CPU 时间。
softirq（通常缩写为 si），代表处理软中断的 CPU 时间。
steal（通常缩写为 st），代表当系统运行在虚拟机中的时候，被其他虚拟机占用的 CPU 时间。
guest（通常缩写为 guest），代表通过虚拟化运行其他操作系统的时间，也就是运行虚拟机的 CPU 时间。guest_nice（通常缩写为 gnice），代表以低优先级运行虚拟机的时间。
```

4. 计算 CPU 使用率，性能工具一般都会取间隔一段时间（比如 3 秒）的两次值，作差后，再计算出这段时间内的平均 CPU 使用率

### 常用
分析方法

1. 性能分析工具给出的都是间隔一段时间的平均 CPU 使用率，所以要注意间隔时间的设置。

2. top 命令，第三行 %Cpu 就是系统的 CPU 使用率。
```
# 默认每3秒刷新一次
$ top
top - 11:58:59 up 9 days, 22:47,  1 user,  load average: 0.03, 0.02, 0.00
Tasks: 123 total,   1 running,  72 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.3 us,  0.3 sy,  0.0 ni, 99.3 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8169348 total,  5606884 free,   334640 used,  2227824 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  7497908 avail Mem

  PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
    1 root      20   0   78088   9288   6696 S   0.0  0.1   0:16.83 systemd
    2 root      20   0       0      0      0 S   0.0  0.0   0:00.05 kthreadd
    4 root       0 -20       0      0      0 I   0.0  0.0   0:00.00 kworker/0:0H
...
```

2. perf 是 Linux 2.6.31 以后内置的性能分析工具。它以性能事件采样为基础，不仅可以分析系统的各种事件和内核性能，还可以用来分析指定应用程序的性能问题。安装 `sudo apt-get install linux-tool`

3. perf top 结果。
```
第一列 Overhead ，是该符号的性能事件在所有采样中的比例，用百分比来表示。
第二列 Shared ，是该函数或指令所在的动态共享对象（Dynamic Shared Object），如内核、进程名、动态链接库名、内核模块名等。
第三列 Object ，是动态共享对象的类型。比如 [.] 表示用户空间的可执行程序、或者动态链接库，而 [k] 则表示内核空间。
最后一列 Symbol 是符号名，也就是函数名。当函数名未知时，用十六进制的地址来表示。
```

4. 碰到常规问题无法解释的 CPU 使用率情况时，首先要想到有可能是短时应用导致的问题，比如有可能是下面这两种情况。第一，应用里直接调用了其他二进制程序，这些程序通常运行时间比较短，通过 top 等工具也不容易发现。第二，应用本身在不停地崩溃重启，而启动过程的资源初始化，很可能会占用相当多的 CPU。对于这类进程，我们可以用 pstree 或者 execsnoop 找到它们的父进程，再从父进程所在的应用入手，排查问题的根源。

5.不可中断状态，表示进程正在跟硬件交互，为了保护进程数据和硬件的一致性，系统不允许其他进程或中断打断这个进程。进程长时间处于不可中断状态，通常表示系统有 I/O 性能问题。僵尸进程表示进程已经退出，但它的父进程还没有回收子进程占用的资源。短暂的僵尸状态我们通常不必理会，但进程长时间处于僵尸状态，就应该注意了，可能有应用程序没有正常处理子进程的退出。

### 不可中断进程和僵尸进程

1. dstat可以同时查看 CPU 和 I/O 这两种资源的使用情况，便于对比分析。
```
间隔1秒输出10组数据
$ dstat 1 10
```
2. 从 dstat 的输出，我们可以看到，每当 iowait 升高（wai）时，磁盘的读请求（read）都会很大。这说明 iowait 的升高跟磁盘的读请求有关，很可能就是磁盘读导致的。

3. 一般要查看某一个进程的资源使用情况，都可以用我们的老朋友 pidstat，不过这次记得加上 -d 参数，以便输出 I/O 使用情况。
```
# -d 展示 I/O 统计数据，-p 指定进程号，间隔 1 秒输出 3 组数据
$ pidstat -d -p 4344 1 3
```

4. strace 正是最常用的跟踪进程系统调用的工具。我们从 pidstat 的输出中拿到进程的 PID 号，比如 6082，然后在终端中运行 strace 命令，并用 -p 参数指定 PID 号。

```
$ strace -p 6082
strace: attach: ptrace(PTRACE_SEIZE, 6082): Operation not permitted
```

5. iowait 高不一定代表 I/O 有性能瓶颈。当系统中只有 I/O 类型的进程在运行时，iowait 也会很高，但实际上，磁盘的读写远没有达到性能瓶颈的程度。

6. 碰到 iowait 升高时，需要先用 dstat、pidstat 等工具，确认是不是磁盘 I/O 的问题，然后再找是哪些进程导致了 I/O。等待 I/O 的进程一般是不可中断状态，所以用 ps 命令找到的 D 状态（即不可中断状态）的进程，多为可疑进程。但这个案例中，在 I/O 操作后，进程又变成了僵尸进程，所以不能用 strace 直接分析这个进程的系统调用。这种情况下，我们用了 perf 工具，来分析系统的 CPU 时钟事件，最终发现是直接 I/O 导致的问题。这时，再检查源码中对应位置的问题，就很轻松了。而僵尸进程的问题相对容易排查，使用 pstree 找出父进程后，去查看父进程的代码，检查 wait() / waitpid() 的调用，或是 SIGCHLD 信号处理函数的注册就行了。