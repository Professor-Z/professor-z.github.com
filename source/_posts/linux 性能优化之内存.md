---
layout: post
title: linux 性能优化之内存
date: 2020-06-07
tags: linux
categories: 操作系统
---

读《Linux性能优化实战》第二部分

<!--more-->

# 内存管理

## 内存映射 

### 摘录

1. 大多数计算机用的主存都是动态随机访问内存（DRAM）。只有内核才可以直接访问物理内存。

2. Linux 内核给每个进程都提供了一个独立的虚拟地址空间，并且这个地址空间是连续的。这样，进程就可以很方便地访问内存，更确切地说是访问虚拟内存。

3. 虚拟地址空间的内部又被分为内核空间和用户空间两部分，不同字长（也就是单个 CPU 指令可以处理数据的最大长度）的处理器，地址空间的范围也不同。

4. 64 位系统的内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。

5. 虽然每个进程的地址空间都包含了内核空间，但这些内核空间，其实关联的都是相同的物理内存。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。

6. 所以，并不是所有的虚拟内存都会分配物理内存，只有那些实际使用的虚拟内存才分配物理内存，并且分配后的物理内存，是通过内存映射来管理的。

7. 为了完成内存映射，内核为每个进程都维护了一张页表，记录虚拟地址与物理地址的映射关系，页表实际上存储在 CPU 的内存管理单元 MMU 中。

8. 而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入内核空间分配物理内存、
更新进程页表，最后再返回用户空间，恢复进程的运行。

9. MMU 并不以字节为单位来管理内存，而是规定了一个内存映射的最小单位，也就是页，通常是 4 KB 大小。这样，每一次内存映射，都需要关联 4 KB 或者 4KB 整数倍的内存空间。

10. Linux 用的正是四级页表来管理内存页，如下图所示，虚拟地址被分为 5 个部分，前 4 个表项用于选择页，而最后一个索引表示页内偏移。

11. 解决页表项过多的问题，Linux 提供了两种机制，也就是多级页表和大页（HugePage）。


## 内存分配

### 摘录
1. 用户空间内存，从低到高分别是五种不同的内存段。
只读段，包括代码和常量等。
数据段，包括全局变量等。
堆，包括动态分配的内存，从低地址开始向上增长。
文件映射段，包括动态库、共享内存等，从高地址开始向下增长。
栈，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。

2. malloc() 是 C 标准库提供的内存分配函数，对应到系统调用上，有两种实现方式，即 brk() 和 mmap()。

3. brk() 方式的缓存，可以减少缺页异常的发生，提高内存访问效率。不过，由于这些内存没有归还系统，在内存工作繁忙时，频繁的内存分配和释放会造成内存碎片。而 mmap() 方式分配的内存，会在释放时直接归还系统，所以每次 mmap 都会发生缺页异常。在内存工作繁忙时，频繁的内存分配会导致大量的缺页异常，使内核的管理负担增大。这也是 malloc 只对大块内存使用 mmap 的原因。

4. 在发现内存紧张时，系统就会通过一系列机制来回收内存，比如下面这三种方式：
回收缓存，比如使用 LRU（Least Recently Used）算法，回收最近使用最少的内存页面；
回收不常访问的内存，把不常用的内存通过交换分区直接写到磁盘中；
杀死进程，内存紧张时系统还会通过 OOM（Out of Memory），直接杀掉占用大量内存的进程。

5. OOM（Out of Memory），其实是内核的一种保护机制。它监控进程的内存使用情况，并且使用 oom_score 为每个进程的内存使用情况进行评分：一个进程消耗的内存越大，oom_score 就越大；一个进程运行占用的 CPU 越多，oom_score 就越小。这样，进程的 oom_score 越大，代表消耗的内存越多，也就越容易被 OOM 杀死，从而可以更好保护系统。

### 疑问
1. 内存分配这块，是所有进程的用户空间的只读段是连续的，还是按照进程分开的？

2. free六列中，每列数据的含义分别为：第一列，total 是总内存大小；第二列，used 是已使用内存的大小，包含了共享内存；第三列，free 是未使用内存的大小；第四列，shared 是共享内存的大小；第五列，buff/cache 是缓存和缓冲区的大小；最后一列，available 是新进程可用内存的大小。

3. available 不仅包含未使用内存，还包括了可回收的缓存，所以一般会比未使用内存更大。不过，并不是所有缓存都可以回收，因为有些缓存可能正在使用中。

4. top 命令结果。VIRT 是进程虚拟内存的大小，只要是进程申请过的内存，即便还没有真正分配物理内存，也会计算在内。RES 是常驻内存的大小，也就是进程实际使用的物理内存大小，但不包括 Swap 和共享内存。SHR 是共享内存的大小，比如与其他进程共同使用的共享内存、加载的动态链接库以及程序的代码段等。%MEM 是进程使用物理内存占系统总内存的百分比。

5. 第一，虚拟内存通常并不会全部分配物理内存。从上面的输出，你可以发现每个进程的虚拟内存都比常驻内存大得多。
第二，共享内存 SHR 并不一定是共享的，比方说，程序的代码段、非共享的动态链接库，也都算在 SHR 里。当然，SHR 也包括了进程间真正共享的内存。所以在计算多个进程的内存使用时，不要把所有进程的 SHR 直接相加得出结果。

## 实战案例

### 摘录笔记

1. linux的内存跟windows的很不一样。类linux的系统会尽量使用内存缓存东西，提供运行效率。所以linux/mac显示的free剩余内存通常很小，但实际上被缓存的cache可能很大，并不代表系统内存紧张！
曾经就闹过笑话，看见系统free值很低，怕程序因为oom被系统杀掉，还特意写个c程序去挤内存。程序不停的申请1MB内存然后memset，随机挑几个位置写，保证申请的都被加载到物理内存中。（跟文中描述的一致，只申请不使用不会加载到物理内存）然后挤的差不多了就把测试程序关掉。看上去free变大了很多很开心。现在想想，就是掩耳盗铃罢了。
以前物理机上还有swap交换分区，现在都是云服务器，基本没有了该分区。也不会遇到因为频繁使用交换分区导致性能下降的问题了。
我内存方面的问题遇到的都比较简单，基本上就是top/free看看系统和各程序的，找到有问题的程序，看看是否有内存泄露。平常不泄漏都是够用的。
redis对内存比较敏感，曾经就因为配置项是默认值，在内存用完后，所有的set操作都直接返回错误，导致线上系统故障。（redis在备份时会新开一个进程，实际使用内存量会翻番。）后来会定期检查redis 的info memory 看内存使用情况。

2. 我的分析步骤：使用top和ps查询系统中大量占用内存的进程，使用cat /proc/[pid]/status和pmap -x pid查看某个进程使用内存的情况和动态变化。

## 理解buffer 和 cacahe

### 摘录
1. Buffers 是内核缓冲区用到的内存，对应的是 /proc/meminfo 中的 Buffers 值。Cache 是内核页缓存和 Slab 用到的内存，对应的是 /proc/meminfo 中的 Cached 与 SReclaimable 之和。

### 案例

1. 结论：Buffer 是对磁盘数据的缓存，而 Cache 是文件数据的缓存，它们既会用在读请求中，也会用在写请求中。

2. 磁盘是一个块设备，可以划分为不同的分区；在分区之上再创建文件系统，挂载到某个目录，之后才可以在这个目录中读写文件。
其实 Linux 中“一切皆文件”，而文章中提到的“文件”是普通文件，磁盘是块设备文件，这些大家可以执行 "ls -l <路径>" 查看它们的区别（输出的含义如果不懂请 man ls 查询）。
在读写普通文件时，会经过文件系统，由文件系统负责与磁盘交互；而读写磁盘或者分区时，就会跳过文件系统，也就是所谓的“裸I/O“。这两种读写方式所使用的缓存是不同的，也就是文中所讲的 Cache 和 Buffer 区别。

## 利用 buffer 和 cache 优化程序

### 摘录
1. 你应该习惯性地先问自己一个问题，你想要做成某件事情，结果应该怎么评估？

2. 缓存的命中率。所谓缓存命中率，是指直接通过缓存获取数据的请求次数，占所有数据请求次数的百分比。

3. 命中率越高，表示使用缓存带来的收益越高，应用程序的性能也就越好。

4. cachestat 提供了整个操作系统缓存的读写命中情况。cachetop 提供了每个进程的缓存命中情况。

5. cachestat 的输出其实是一个表格。每行代表一组数据，而每一列代表不同的缓存统计指标。这些指标从左到右依次表示

### 疑问
1. 案例1中，并不是所有的读都落到了磁盘上，事实上读请求的缓存命中率只有 50% 。不应该是全落在磁盘上吗。
```
我是小白）
1.dd命令前清理了缓存，为什么缓存命中率是百分之49.8呢？（都已经没有缓存了，按理说是0）
2.绕过了系统缓存，为什么缓存命中率还百分之百？
作者回复: 1. 预读，2. 还有元数据缓存
```

## 内存泄漏的定位和处理

### 定位

1. 常见问题：没正确回收分配后的内存，导致了泄漏。访问的是已分配内存边界外的地址，导致程序异常退出，等等。

2. 用户空间内存包括多个不同的内存段，比如（地址由低到高）只读段、数据段、堆、文件映射段、栈等。这些内存段正是应用程序使用内存的基本方式。

3. 内存泄漏的情况。

局部变量，会从内存空间的栈中分配内存；一旦程序运行超出了这个局部变量的作用域，栈内存就会被系统自动回收，所以不会产生内存泄漏的问题。

事先并不知道数据大小，所以你就要用到标准库函数 malloc() _，_ 在程序中动态分配内存。这时候，系统就会从内存空间的堆中分配内存。

堆内存由应用程序自己来分配和管理。除非程序退出，这些堆内存并不会被系统自动释放，而是需要应用程序明确调用库函数 free() 来释放它们。如果应用程序没有正确释放堆内存，就会造成内存泄漏。

只读段，包括程序的代码和常量，由于是只读的，不会再去分配新的内存，所以也不会产生内存泄漏。

数据段，包括全局变量和静态变量，这些变量在定义时就已经确定了大小，所以也不会产生内存泄漏。

最后一个内存映射段，包括动态链接库和共享内存，其中共享内存由程序动态分配和管理。所以，如果程序在分配后忘了回收，就会导致跟堆内存类似的泄漏问题。

### 案例
```
root@instance-1:/home/zsh# memleak -a -p $(pidof app)
Attaching to pid 19013, Ctrl+C to quit.
perf_event_open(/sys/kernel/debug/tracing/events/uprobes/p__proc_19013_root_lib_x86_64_linux_gnu_libc_2_27_so_0x97070_19013_bcc_19086/id): Input/output error
Traceback (most recent call last):
  File "/usr/share/bcc/tools/memleak", line 433, in <module>
    attach_probes("malloc")
  File "/usr/share/bcc/tools/memleak", line 423, in attach_probes
    pid=pid)
  File "/usr/lib/python2.7/dist-packages/bcc/__init__.py", line 1108, in attach_uprobe
    raise Exception("Failed to attach BPF to uprobe")
Exception: Failed to attach BPF to uprobe
```

## swap 

### 摘录

1. 运行了大内存的应用程序，导致系统的内存资源紧张时，系统又会如何应对呢？这其实会导致两种可能结果，内存回收和 OOM 杀死进程

2. 内存回收，也就是系统释放掉可以回收的内存，比如我前面讲过的缓存和缓冲区，就属于可回收内存。它们在内存管理中，通常被叫做文件页（File-backed Page）。

3. 大部分文件页，都可以直接回收，以后有需要时，再从磁盘重新读取就可以了。而那些被应用程序修改过，并且暂时还没写入磁盘的数据（也就是脏页），就得先写入磁盘，然后才能进行内存释放。这些脏页，一般可以通过两种方式写入磁盘。可以在应用程序中，通过系统调用 fsync ，把脏页同步到磁盘中；也可以交给系统，由内核线程 pdflush 负责这些脏页的刷新。

4. 除了缓存和缓冲区，通过内存映射获取的文件映射页，也是一种常见的文件页。它也可以被释放掉，下次再访问的时候，从文件重新读取。

5. 应用程序动态分配的堆内存，也就是我们在内存管理中说到的匿名页（Anonymous Page）。Swap 把其中不常访问的内存先写到磁盘中，然后释放这些内存，给其他更需要的进程使用。再次访问这些内存时，重新从磁盘读入内存就可以了。

6. Swap 说白了就是把一块磁盘空间或者一个本地文件（以下讲解以磁盘为例），当成内存来使用。它包括换出和换入两个过程。

7. 有一个专门的内核线程用来定期回收内存，也就是 kswapd0。为了衡量内存的使用情况，kswapd0 定义了三个内存阈值（watermark，也称为水位），分别是页最小阈值（pages_min）、页低阈值（pages_low）和页高阈值（pages_high）。剩余内存，则使用 pages_free 表示。

8. 一旦剩余内存小于页低阈值，就会触发内存的回收。这个页低阈值，其实可以通过内核选项 /proc/sys/vm/min_free_kbytes 来间接设置。

9. 某个 Node 内存不足时，系统可以从其他 Node 寻找空闲内存，也可以从本地内存中回收内存。具体选哪种模式，你可以通过 /proc/sys/vm/zone_reclaim_mode 来调整。它支持以下几个选项：默认的 0 ，也就是刚刚提到的模式，表示既可以从其他 Node 寻找空闲内存，也可以从本地回收内存。1、2、4 都表示只回收本地内存，2 表示可以回写脏数据回收内存，4 表示可以用 Swap 方式回收内存。

10. Linux 提供了一个 /proc/sys/vm/swappiness 选项，用来调整使用 Swap 的积极程度。

11. swappiness 的范围是 0-100，数值越大，越积极使用 Swap，也就是更倾向于回收匿名页；数值越小，越消极使用 Swap，也就是更倾向于回收文件页。

### 留言摘录

1. 事实上不仅 hadoop，包括 ES 在内绝大部分 Java 的应用都建议关 swap，这个和 JVM 的 gc 有关，它在 gc 的时候会遍历所有用到的堆的内存，如果这部分内存是被 swap 出去了，遍历的时候就会有磁盘IO。

2. 请问老师、为什么kubernetes要关闭swap呢？
作者回复: 一个是性能问题，开启swap会严重影响性能（包括内存和I/O）；另一个是管理问题，开启swap后通过cgroups设置的内存上限就会失效。


### 案例笔记

1. 现象不明显。

## 内存问题查找套路


### 疑问

1. 内存回收具体是什么样的？虚拟内存和物理内存的对应是静态的吗？

2. 磁盘和文件的区别。
- 你在很多地方都会看到这句话， Linux 中一切皆文件。换句话说，你可以通过相同的文件接口，来访问磁盘和文件（比如 open、read、write、close 等）。
我们通常说的“文件”，其实是指普通文件。
而磁盘或者分区，则是指块设备文件。