---
title: JavaScript基础知识点总结
tags:
---

## 面向对象

### 创建对象的几种方法 

1.**工厂模式**

描述：使用函数创建属性和方法相同的对象。

缺点：没有解决对象识别的问题。

2.**构造函数模式**

描述： 特正是属性赋值给this, 需要使用 new 操作符，需要大写首字母。解决了对象识别问题，使用 constructor 和 instanceof 都能验证是否属于同一对象。

缺点：没有共享方法，浪费空间。

3.**原型模式**

描述：首先需要对原型对象的理解（实例，构造函数，原型对象三者指向关系）。把属性和方法都设置在构造函数的原型对象上面，解决了共享方法的问题。

缺点： 实例之间共享方法的同时也共享了引用类型的属性值。

4.**组合使用构造函数模式和原型模式**

描述：构造函数模式用于定义实例属性，原型模式用于定义方法和共享属性。

5.**动态原型模式**

描述：在构造函数内部使用条件判断需要的方法是否存在，否则在原型上定义需要的方法。

6.**寄生构造函数模式**
描述：跟工厂模式一样，多了使用 new 操作符。

6.**稳妥构造函数模式**

描述：跟寄生构造函数一样，不过在方法中不使用 this,同时不使用 new 操作符。

### 实现继承的几种方法

ECMAScript 函数没有签名，只支持实现继承，不支持接口继承。主要依靠原型链来实现。

1.**原型链**

描述：将子类型的构造函数的 prototype 指针指向父类型的一个实例。

缺点：父类型的实例中可能有引用类型的属性值，又会导致共享属性的问题。

2.**借用构造函数（伪造对象、经典继承）**

描述：在子类型的构造函数内部使用 call,apply 调用父类型的构造函数。可以传递参数。

缺点：父类型的方法都在子类型的构造函数中定义（而不是原型对象上），无法共享方法了。而且父类型原型中的方法也无法继承。

3.**组合继承（伪经典继承）**

描述：需要父类型在构造函数中定义非共享属性，在原型对象中定义方法。然后子类型在构造函数中用 call,apply 调用父类型的构造函数，然后把 prototype 指向父类型的一个实例。该模式是最常用的继承模式。

4.**原型式继承**

描述：借助原型可以基于已有对象创建新对象（借助空的构造函数）。本质上是对已有对象的浅复制。等于 Object.create()方法。

5.**寄生式继承**

描述：在原型式继承的基础上，内部做一些添加方法之类的行为，然后返回浅复制的对象。

6.**寄生组合式继承**

描述：组合继承中，会在指定子类型的 prototype 时生成一遍父类型的属性，又在子类型构造函数中借用父类型的构造函数生成了父类型的属性（同时屏蔽了 prototype 中的属性值，避免共享）。这样会浪费空间。寄生组合式继承在指定子类型的 prototype 时，通过原型式继承中的方法（浅复制+原型链关系）创建父类型原型的副本并赋值给子类型的 prototype 指针。从而避免在子类型原型中创建属性值。同时保持了原型链不变。